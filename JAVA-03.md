#一。
1. 整数型有 int,byte,short,long。字符数为char。浮点数有float,double。布尔型为boolean(结果仅为ture或false)。
2. byte 的取值范围：-128～127（-2的7次方到2的7次方-1）  占1个字节

   short 的取值范围：-32768～32767（-2的15次方到2的15次方-1） 占2个字节

   int 的取值范围：-2147483648～2147483647（-2的31次方到2的31次方-1） 占4个字节

   long 的取值范围：-9223372036854774808～9223372036854774807（-2的63次方到2的63次方-1）    占8个字节

   （*一个字节8个bite也就是一个字节可以储存到2^8-1（从0开始），然后正负分半得出上述范围。*）

3. 自动类型转换（*没有（int）这样之类的人为操作*）
   b=52 
   自动将0字符按照ASCLL码表转换为48
   
#二。
1. 

![[运行结果.png]]
++a指先将a加一，而b++指到下一行才加一。所以第四行代码是指将a+1加上b的值赋给c，然后把b加一，所以后面c为13而最后a，b结果都加了1。

#三。
1. 拓展:![[拓展1.png]]
   第一个false：new Integer（）中每一次都会创建一个新的对象，虽然数值都是18但是是不同的对象。
   第二个true：Integer.valueOf()中多次调用取得的是同一个对象的引用。
   第三个false：数据太大，溢出了。Integer的范围应该是-128~127之间。
2. 拓展：假设都是int类型，则a=00000000 00000000 00000000 00000010
                        -a的原码为10000000 00000000 00000000 00000010
                         反码为11111111 11111111 11111111 11111101（原码最高位代表符号的不变，其他的都01互换）。
                         补码为11111111 11111111 11111111 11111110（反码+1）
        a&（-a）即二进制一一对应，不同为0同为1，则为
        00000000 00000000 00000000 00000010是+2
    对于任意的非负整数a，其a&(-a)的结果为 **a的二进制最低位的 1 及其后面的所有的 0 的二进制构成的数值。**（*百度出来的😭，试了几个数，确实如此*）
